---
title: "study 1 analysis"
output: 
  html_document:
      toc: true
      toc_float: true
      toc_depth: 3
      number_sections: true
date: "2024-10-28"
---

What this script does:
- proceeds using outputs of pre-processing script
- generates Causal Task and Sorting Task rdms, correlations with theoretical models, correlations within subjects

Study description
- Study ran on 12/13/24 on Connect CloudResearch, 50 participants
- Subject selection criteria: 95% approval rate, minimum 10 previous submissions, and fluent in English

# Setup

## load packages

```{r, setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)

library(pacman)
pacman::p_load(tidyverse,
               ggforce,
               conflicted,
               here,
               cowplot,
               lme4,
               lmerTest,
               effects,
               Hmisc,
               performance,
               purrr,
               readr,
               igraph,
               ggraph,
               tidygraph,
               visNetwork,
               scales,
               patchwork,
               corrplot)

walk(c("select", "filter", "rename", "mutate", "summarise", "summarize"), ~ conflict_prefer(.x, "dplyr"))
theme_set(theme_bw())
sessionInfo()

```

## read data and set variables

```{r}
desired_order <- c("see something", "hear something", "choose what to do", 
                   "remember something", "think about something", "reach for something", 
                   "sit down", "jump up and down", "kick something", "take a walk", 
                   "get tired", "become hungry", "feel scared", "experience pain", "get sick")

freesort_columns <- c("subject_id", "x", "y", "item")
causation_columns <- c("subject_id", "itemA", "itemB", "response")

# paths
base_path <- here("code", "analysis", "pilot")
data_original_path <- paste0(base_path, "/data-combined/pilot05_121324_n50_combined_17")
snapshots_input_path <- paste0(base_path, "/snapshots_study1_preprocessing_analysis")
snapshots_output_path <- paste0(base_path, "/snapshots_study1_final_analysis")

data_combined_path <- paste0(snapshots_input_path, "/pilot_121424_combined.csv")
theories_all_input_path <- paste0(snapshots_input_path, "/pilot_121424_theories_all.csv") #RENAMED FROM d_all_theories
theories_input_path <- paste0(snapshots_input_path, "/pilot_121424_theories.csv") #RENAMED FROM d_theories_Cctegories
correlations_output_path <- paste0(snapshots_output_path, "/correlations.csv")

# read data
d <- read_csv(data_combined_path) %>% 
  rename("subject_id" = filename) %>% 
  mutate(
    subject_id = factor(subject_id), # Convert to factor to establish levels
    subject_index = as.integer(subject_id), # Assign a numeric index based on factor levels
    subject_id = sprintf("subj_%02d", subject_index) # Create the new sequential ID
  ) %>%
  select(-subject_index) # Remove the temporary index column if no longer needed

```


# Freesort

## reshape data

```{r}
#get item pairs per person
df_distances <- d %>%
  filter(trial_type == "free_sort") %>%
  select(all_of(freesort_columns)) %>%
  select(subject_id, item) %>%
  group_by(subject_id) %>%
  summarize(pairs = list(expand.grid(itemA = item, itemB = item, stringsAsFactors = FALSE))) %>%
  unnest(pairs) %>%
  filter(itemA != itemB) %>% #remove self-pairs
  left_join(d %>% 
              filter(trial_type == "free_sort") %>% 
              select(all_of(freesort_columns)), by = c("subject_id", "itemA" = "item")) %>% #append itemA positions
  rename(x_itemA = x, y_itemA = y) %>% 
  left_join(d %>% 
              filter(trial_type == "free_sort") %>% 
              select(all_of(freesort_columns)), by = c("subject_id", "itemB" = "item")) %>% #append itemB positions
  rename(x_itemB = x, y_itemB = y) %>% 
  group_by(subject_id) %>% 
  mutate(euclidean_distance = sqrt((x_itemA - x_itemB)^2 + (y_itemA - y_itemB)^2),
         # emp_euclidean = ((euclidean_distance - min(euclidean_distance)) /
         #                           (max(euclidean_distance) - min(euclidean_distance)))

         emp_euclidean = (euclidean_distance - min(euclidean_distance)) /
                                   (max(euclidean_distance) - min(euclidean_distance))
         ) %>% #normalizing euclidean distances
  select(subject_id, itemA, itemB, emp_euclidean) %>% 
  ungroup() %>%
  mutate(itemA = factor(itemA, levels = desired_order),
         itemB = factor(itemB, levels = desired_order))

```

## plot subject-specific raw responses

```{r, fig.width = 14, fig.height = 10}
d %>% 
  filter(trial_type == "free_sort") %>%
  mutate(y = 500 - y) %>% #invert y axis
  ggplot(aes(x = x, y = y)) +
  geom_point() +
  geom_text(aes(label = item), size = 3, vjust = -.2) +
  facet_wrap(~subject_id)

```

## plot average raw responses

```{r}
# pdf("my_plot_average.pdf", width = 7, height = 4)  # Width and height are in inches
d %>% 
  filter(trial_type == "free_sort") %>%
  mutate(y = 500 - y) %>% 
  group_by(item) %>% 
  mutate(mean_x = mean(x),
            mean_y = mean(y)) %>% 
  ungroup() %>% 
  distinct(item, .keep_all = TRUE) %>% 
  select(-subject_id) %>% 
  ggplot(aes(x = mean_x, y = mean_y)) +
  geom_point() +
  geom_text(aes(label = item), vjust = -1) +
  labs(title = "Average Raw Responses")

```

## plot subject-specific freesort rdms

```{r}
plot_rdm <- function(data, subject, desired_order) { # Function to create RDM plot for a single subject
  df_matrix <- data %>%
    filter(subject_id == subject) %>%
    select(-subject_id) %>%
    select(itemA, itemB, emp_euclidean) %>% 
    pivot_wider(names_from = itemB, values_from = emp_euclidean) %>%
    column_to_rownames("itemA")
  
  df_matrix <- df_matrix[desired_order, desired_order] #reorder matrix
  diag(df_matrix) <- 0  # Set diagonal to 0
  
  corrplot(as.matrix(df_matrix), method = "color", is.corr = FALSE,
    tl.col = "black", title = paste("RDM - ", subject),
    mar = c(0, 0, 2, 0), addgrid.col = "darkgray"
  )
}

subject_ids <- unique(df_distances$subject_id)

#generate plots
# plots <- map(subject_ids, ~plot_rdm(df_distances, .x, desired_order)) #run this to generate plots

# save plots with subject name as file name
 
# Generate unique subject IDs and save plots
new_names <- paste0("subj_", str_pad(seq_along(subject_ids), width = 2, pad = "0"))  # Generate new subject names

for (i in seq_along(subject_ids)) {  # Loop to save each plot as a separate PDF
  # Specify the path to save the PDF in the "figures" subfolder
  pdf(file = paste0(base_path, "/figures/freesort/", new_names[i], ".pdf"), width = 8, height = 6)  # Open a PDF device
  plot_rdm(df_distances, subject_ids[i], desired_order)  # Generate the plot
  dev.off()  # Close the device to save the file
}

```

## plot average freesort rdm 


```{r}
df_mean_distances <- df_distances %>% 
  unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>% 
  group_by(item_pairs) %>% 
  mutate(mean_emp_euclidean = mean(emp_euclidean)) %>% 
  distinct(item_pairs, .keep_all = TRUE) %>% 
  ungroup() %>% 
  select(-c(item_pairs, subject_id, emp_euclidean))  %>% 
  mutate(itemA = factor(itemA, levels = desired_order),
         itemB = factor(itemB, levels = desired_order))
  
# matrixify and plot
df_mean_distances_matrix <- df_mean_distances %>% 
  pivot_wider(names_from = itemB, values_from = mean_emp_euclidean) %>% 
  column_to_rownames("itemA")  
  
df_mean_distances_matrix <- df_mean_distances_matrix[desired_order, desired_order] #reorder matrix

diag(df_mean_distances_matrix) <- 0 #set diagonals 

# pdf(file = here(rdm_outputs_path, "figures/freesort/averageEuclideanRDM.pdf"), width = 8, height = 6)

corrplot(as.matrix(df_mean_distances_matrix), method = "color", is.corr = FALSE, 
         tl.col = "black", title = "Average Freesort RDM", mar = c(0, 0, 2, 0),
         addgrid.col = "darkgray")

```

## figure for paper

```{r, fig.width = 12, fig.height = 12}
# Define colors for the 3 groups for average rdm label
group_colors <- c("#f7bf2a", "#69ad44", "#f36b2d") 

# Map each item to a color based on its group
item_colors <- setNames(c(rep(group_colors[1], 5), 
                          rep(group_colors[2], 5), 
                          rep(group_colors[3], 5)), 
                        desired_order)


# Ensure the colors align with the matrix order
label_colors <- item_colors[rownames(df_mean_distances_matrix)]

# Define a custom cool-to-warm palette
custom_palette <- colorRampPalette(c("blue", "red")) # Blue for low, white for mid, red for high

#small image
corrplot(
  as.matrix(df_mean_distances_matrix),
  method = "color",
  is.corr = FALSE,
  col = custom_palette(200),
  tl.col = "black", #could be label_colors
  title = "Average Freesort RDM",
  mar = c(0, 0, 2, 0),
  addgrid.col = "darkgray",
  cl.offset = 1.0,  # Push labels even further
  cl.cex = 0.8,     # Slightly smaller label text
  cl.ratio = 0.22   # Widen the legend bar. Change this to push words far away
)


#large image
corrplot(
  as.matrix(df_mean_distances_matrix),
  method = "color",
  is.corr = FALSE,
  col = custom_palette(200),
  #tl.col = "black", #could be label_colors
  tl.col = label_colors, #could be label_colors
  tl.cex = 2,
  title = "Average Freesort RDM",
  mar = c(0, 0, 2, 0),
  addgrid.col = "darkgray",
  cl.offset = 1.0,  # Push labels even further
  cl.cex = 2,     # Slightly smaller label text
  cl.ratio = 0.22,   # Widen the legend bar. Change this to push words far away
  cex.main = 5
)

```

# Causation

## reshape data

```{r}
df_causation <- d %>%
    filter(trial_type == "causation") %>% 
    filter(!attention_check) %>% 
    select(all_of(causation_columns)) %>% 
    mutate(prenorm_response = 1 - response / 100,
           emp_causal_judgments = (prenorm_response - min(prenorm_response)) /
                            (max(prenorm_response) - min(prenorm_response))) %>% #redundant since data already in 0 - 100 range
    dplyr::select(-c(response, prenorm_response)) 

```

## plot subject-specific causal RDMs

```{r}
plot_causation_rdm <- function(data, subject, desired_order) {
  # Filter and process data for the specific subject
  df_matrix <- data %>%
    filter(subject_id == subject) %>%
    select(-subject_id) %>%
    select(itemA, itemB, emp_causal_judgments) %>% 
    pivot_wider(names_from = itemB, values_from = emp_causal_judgments) %>%
    column_to_rownames("itemA")
  
  # Reorder matrix and set diagonal to zero
  df_matrix <- df_matrix[desired_order, desired_order]
  diag(df_matrix) <- 0
  
  # Plot the RDM
  corrplot(as.matrix(df_matrix), method = "color", is.corr = FALSE,
           tl.col = "black", title = paste("Causal RDM - ", subject),
           mar = c(0, 0, 2, 0), addgrid.col = "darkgray")
}

subject_ids <- unique(df_causation$subject_id)

#generate plots
# plots <- map(subject_ids, ~plot_causation_rdm(df_causation, .x, desired_order)) #run this to generate plots

# save plots with subject name as file name
 
# Generate unique subject IDs and save plots
new_names <- paste0("subj_", str_pad(seq_along(subject_ids), width = 2, pad = "0"))  # Generate new subject names

for (i in seq_along(subject_ids)) {  # Loop to save each plot as a separate PDF
  # Specify the path to save the PDF in the "figures" subfolder
  pdf(file = paste0(base_path, "/figures/causation/", new_names[i], ".pdf"), width = 8, height = 6)  # Open a PDF device
  plot_causation_rdm(df_causation, subject_ids[i], desired_order)  # Generate the plot
  dev.off()  # Close the device to save the file
}

```

## plot average causal RDM

```{r}
df_mean_causation <- df_causation %>% 
  mutate(item_pairs = str_c(itemA, itemB, sep = "-"))  %>%
  group_by(item_pairs) %>%
  mutate(mean_dissimilarity = mean(emp_causal_judgments, na.rm = TRUE)) %>%  #average across participants
  ungroup() 

df_causation_rdm <- df_mean_causation %>%
  distinct(item_pairs, .keep_all = TRUE) %>% 
  select(itemA, itemB, mean_dissimilarity) %>% 
  pivot_wider(names_from = itemB, values_from = mean_dissimilarity) %>%
  column_to_rownames("itemA")  

df_causation_rdm <- df_causation_rdm[desired_order, desired_order]

# pdf(file = here(rdm_outputs_path, "figures/causation/averageCausalRDM.pdf"), width = 8, height = 6)  

corrplot(as.matrix(df_causation_rdm), method = "color", is.corr = FALSE, tl.col = "black",
         title = "Average Causal RDM", mar = c(0, 0, 2, 0), addgrid.col = "darkgray")

```

```{r}


asymmetry_df

corrplot(as.matrix(asymmetry_df), method = "color", is.corr = FALSE, tl.col = "black",
         title = "Average Causal RDM", mar = c(0, 0, 2, 0), addgrid.col = "darkgray")

```

## clustering things

```{r}
causal_rdm <- df_causation_rdm 
distance_matrix <- as.dist(causal_rdm)

# Perform hierarchical clustering
hc <- hclust(distance_matrix, method = "ward.D2")

# Plot dendrogram
plot(hc, main = "Hierarchical Clustering of Causal RDM", xlab = "", sub = "")

library(pheatmap)

# Scale the data
scaled_rdm <- as.matrix(scale(causal_rdm))

# Plot heatmap
pheatmap(scaled_rdm, clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "ward.D2", 
         main = "Heatmap of Causal RDM Clustering")
```



# Asymmetry package

## example from rdocumentation

```{r}
data("asymscalexample")
t<-asymscal(asymscalexample, ndim = 2, itmax = 10000, eps = 1e-10)
t$cweights
round(t$cweights, 3)
plot(t, plot.type = "confplot")
plot(t, plot.type = "bubbleplot")
plot(t, plot.type = "stressplot")

str(t)

summary(asymscalexample)
asymscalexample

install.packages("Matrix")
library(Matrix)

library(asymmetry)
isSymmetric(asymscalexample)

?asymmetry
?asymscal
```

## testing on my data

```{r}
library(asymmetry)

causal_rdm <- df_causation_rdm 

t<-asymscal(as.matrix(causal_rdm), ndim = 2, itmax = 10000, eps = 1e-10)
t$cweights
round(t$cweights, 3)
plot(t, plot.type = "confplot")
plot(t, plot.type = "bubbleplot")
plot(t, plot.type = "stressplot")

#stress checks
t$stress
t2<-asymscal(as.matrix(causal_rdm), ndim = 5, itmax = 10000, eps = 1e-10)

# see dimension cordinates
print(round(t2$gspace, 3))  
print(round(t2$cweights, 3))  # See which dimensions contribute most to asymmetry

#heatmap with gpt
mds_long <- melt(t2$gspace)
colnames(mds_long) <- c("Item", "Dimension", "Value")

ggplot(mds_long, aes(x = Dimension, y = Item, fill = Value)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
  theme_minimal() +
  labs(title = "Heatmap of MDS Dimensions", x = "MDS Dimension", y = "Item", fill = "Value") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


## Factor analysis

```{r}
# Compute correlation matrix (FA needs correlations, not distances)
cor_matrix <- cor(as.matrix(causal_rdm), use = "pairwise.complete.obs")

# Print the correlation matrix
print(round(cor_matrix, 3))

library(psych)  # For factor analysis

# Determine number of factors using parallel analysis
fa_parallel <- fa.parallel(cor_matrix, fa = "fa", n.iter = 100)

# Run Factor Analysis with the suggested number of factors
fa_model <- fa(cor_matrix, nfactors = 3, rotate = "varimax", fm = "ml")  # Adjust `nfactors` if needed

# Print factor loadings
print(fa_model$loadings)
```


## analyzing asymmetry with 2d view

```{r}
library(reshape2)
library(ggplot2)

# Convert causal_rdm to matrix if needed
causal_matrix <- as.matrix(causal_rdm)

# Compute the pairwise asymmetry matrix
asymmetry_matrix <- causal_matrix - t(causal_matrix)  # Subtract transposed matrix

# Convert matrix to long format ensuring row and column names are retained
asymmetry_long <- melt(asymmetry_matrix, varnames = c("Var1", "Var2"), value.name = "Asymmetry_Score")

# Remove cases where Var1 == Var2 (diagonal, which is always 0)
asymmetry_long <- asymmetry_long[asymmetry_long$Var1 != asymmetry_long$Var2, ]

# Sort by strongest asymmetries (absolute values)
asymmetry_long <- asymmetry_long[order(abs(asymmetry_long$Asymmetry_Score), decreasing = TRUE), ]


asymmetry_long %>% 
  filter(Var1 == c("get tired", "jump up and down")) %>% 
  filter()

# Print top 10 asymmetric pairs
print(head(asymmetry_long, 10))

```






#unfolding
-mds that uses divergences. callback libler divergence. its a statistical divergence. 
-nonparametric anova (varanova). people use mds to viaualize the nonarametric anova
-factor analysis. clusters ocould be compatible with correlation structure, more like a factor analysis. 

```{r}
# Convert the matrix to a data frame and retain row names as labels
mds_df <- as.data.frame(mds_result$gspace)
mds_df$Item <- rownames(mds_result$gspace)  # Add labels

# Rename columns explicitly
colnames(mds_df) <- c("Dim1", "Dim2", "Item")

# Check if the dataframe is correct
print(mds_df)

# Now plot the MDS solution
library(ggplot2)
library(ggrepel)

ggplot(mds_df, aes(x = Dim1, y = Dim2, label = Item)) +
  geom_point(size = 3, color = "blue") +
  geom_text_repel() +
  theme_minimal() +
  labs(title = "Asymmetric MDS Visualization", x = "Dimension 1", y = "Dimension 2")
```

```{r}

# Load the required package
install.packages("pwr")  # If not already installed
library(pwr)

# Given values
t_value <- 9.76
n_pilot <- 50

# Compute Cohen's d
cohen_d <- t_value / sqrt(n_pilot)

# Perform power analysis to find required sample size for replication
power_analysis <- pwr.t.test(d = cohen_d, power = 0.9, sig.level = 0.05, type = "one.sample", alternative = "two.sided")

# Display required sample size
ceiling(power_analysis$n)  # Rounds up to the nearest integer



pwr.t.test(d = 1.0, power = 0.80, sig.level = 0.05, type = "one.sample", alternative = "two.sided")
pwr.t.test(d = 0.8, power = 0.80, sig.level = 0.05, type = "one.sample", alternative = "two.sided")

```





```{r}

# Treat rows as observations and columns as features
causal_rdm <- as.matrix(causal_rdm)  # Ensure it's a matrix

# Scale the data for clustering
scaled_rdm <- scale(causal_rdm)

# Perform hierarchical clustering on rows
row_hc <- hclust(dist(scaled_rdm), method = "ward.D2")

# Perform hierarchical clustering on columns
col_hc <- hclust(dist(t(scaled_rdm)), method = "ward.D2")

# Plot heatmap with row and column clustering
pheatmap(
  scaled_rdm,
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "ward.D2",
  cluster_rows = row_hc,   # Use the row clustering
  cluster_cols = col_hc,   # Use the column clustering
  main = "Asymmetric Clustering of Causal RDM"
)
```










































































# Order effects

## causal-causal vs freesort-freesort correlation

todo: round emp_euclidean to 2dp, like causation

```{r}
  #===================================================================================THISSS works for the first part
  #later, add df_combined to top of the script

freesort_columns_with_trial_order <- c("subject_id", "x", "y", "item", "trial_type", "trial_type_order")

df_freesort_with_order <- d %>%
  filter(trial_type == "free_sort") %>%
  select(all_of(freesort_columns)) %>%
  select(subject_id, item) %>%
  group_by(subject_id) %>%
  summarize(pairs = list(expand.grid(itemA = item, itemB = item, stringsAsFactors = FALSE))) %>%
  unnest(pairs) %>%
  filter(itemA != itemB) %>% #remove self-pairs
  left_join(d %>% 
              filter(trial_type == "free_sort") %>% 
              select(all_of(freesort_columns_with_trial_order)), by = c("subject_id", "itemA" = "item")) %>% #append itemA positions
  rename(x_itemA = x, y_itemA = y) %>% 
  left_join(d %>% 
              filter(trial_type == "free_sort") %>% 
              select(all_of(freesort_columns)), by = c("subject_id", "itemB" = "item")) %>% #append itemB positions
  rename(x_itemB = x, y_itemB = y) %>% 
  group_by(subject_id) %>% 
  mutate(euclidean_distance = sqrt((x_itemA - x_itemB)^2 + (y_itemA - y_itemB)^2),
         emp_euclidean = ((euclidean_distance - min(euclidean_distance)) /
                                   (max(euclidean_distance) - min(euclidean_distance)))) %>% #normalizing euclidean distances
  select(subject_id, itemA, itemB, emp_euclidean, trial_type, trial_type_order) %>% 
  ungroup() %>%
  mutate(itemA = factor(itemA, levels = desired_order),
         itemB = factor(itemB, levels = desired_order)) 

df_combined <- df_freesort_with_order %>% 
  mutate(trial_type_order = ifelse(trial_type_order == "first", "causation_second", "causation_first")) %>% 
  select(-trial_type) %>% 
  left_join(df_causation %>% #wow trial type ceases to matter if we have the scores by trial_type
              filter(itemA != itemB) %>% 
              select(everything()),
            by = c("subject_id", "itemA", "itemB")) %>% #this should be done early!
  relocate(trial_type_order, .after = "itemB")

df_causation_first <- df_combined %>% 
  filter(trial_type_order == "causation_first")

df_freesort_first <- df_combined %>% 
  filter(trial_type_order == "causation_second")

# Getting causal RDMs

# causation-first group
df_causal_rdm_causation_first <- df_causation_first %>%
  mutate(item_pairs = str_c(itemA, itemB, sep = "-")) %>%
  group_by(item_pairs) %>%
  mutate(mean_causal = mean(emp_causal_judgments, na.rm = TRUE)) %>%
  ungroup() %>%
  distinct(item_pairs, .keep_all = TRUE) %>%
  select(itemA, itemB, mean_causal) %>%
  pivot_wider(names_from = itemB, values_from = mean_causal) %>%
  column_to_rownames("itemA")

df_causal_rdm_causation_first <- df_causal_rdm_causation_first[desired_order, desired_order]  # Reorder matrix

# freesort-first group
df_causal_rdm_freesort_first <- df_freesort_first %>%
  mutate(item_pairs = str_c(itemA, itemB, sep = "-")) %>%
  group_by(item_pairs) %>%
  mutate(mean_causal = mean(emp_causal_judgments, na.rm = TRUE)) %>%
  ungroup() %>%
  distinct(item_pairs, .keep_all = TRUE) %>%
  select(itemA, itemB, mean_causal) %>%
  pivot_wider(names_from = itemB, values_from = mean_causal) %>%
  column_to_rownames("itemA")

df_causal_rdm_freesort_first <- df_causal_rdm_freesort_first[desired_order, desired_order]  # Reorder matrix

# Getting freesort RDMs

# causation-first group
df_freesort_rdm_causation_first <- df_causation_first %>%
  mutate(item_pairs = str_c(itemA, itemB, sep = "-")) %>%
  group_by(item_pairs) %>%
  mutate(mean_euclidean = mean(emp_euclidean, na.rm = TRUE)) %>%
  ungroup() %>%
  distinct(item_pairs, .keep_all = TRUE) %>%
  select(itemA, itemB, mean_euclidean) %>%
  pivot_wider(names_from = itemB, values_from = mean_euclidean) %>%
  column_to_rownames("itemA")

df_freesort_rdm_causation_first <- df_freesort_rdm_causation_first[desired_order, desired_order]  # Reorder matrix

# freesort-first group
df_freesort_rdm_freesort_first <- df_freesort_first %>%
  mutate(item_pairs = str_c(itemA, itemB, sep = "-")) %>%
  group_by(item_pairs) %>%
  mutate(mean_euclidean = mean(emp_euclidean, na.rm = TRUE)) %>%
  ungroup() %>%
  distinct(item_pairs, .keep_all = TRUE) %>%
  select(itemA, itemB, mean_euclidean) %>%
  pivot_wider(names_from = itemB, values_from = mean_euclidean) %>%
  column_to_rownames("itemA")

df_freesort_rdm_freesort_first <- df_freesort_rdm_freesort_first[desired_order, desired_order]  # Reorder matrix


# Flatten the upper triangles of the RDMs for correlation
flatten_rdm <- function(matrix) {
  matrix[upper.tri(matrix)]
}

# Extract upper triangles
causation_rdm_correlation <- cor(flatten_rdm(as.matrix(df_causal_rdm_causation_first)),
                                 flatten_rdm(as.matrix(df_causal_rdm_freesort_first)),
                                 method = "spearman")

freesort_rdm_correlation <- cor(flatten_rdm(as.matrix(df_freesort_rdm_causation_first)),
                                flatten_rdm(as.matrix(df_freesort_rdm_freesort_first)),
                                method = "spearman")

# Print correlations
print(causation_rdm_correlation)
print(freesort_rdm_correlation)

# Compute correlation difference
correlation_difference <- causation_rdm_correlation - freesort_rdm_correlation

```

## causal-freesort vs causal freesort correlation

```{r}
# Extract upper triangles
causation_first_rdm_correlation <- cor(flatten_rdm(as.matrix(df_causal_rdm_causation_first)),
                                 flatten_rdm(as.matrix(df_freesort_rdm_causation_first)),
                                 method = "spearman")

freesort_first_rdm_correlation <- cor(flatten_rdm(as.matrix(df_causal_rdm_freesort_first)),
                                flatten_rdm(as.matrix(df_freesort_rdm_freesort_first)),
                                method = "spearman")

# Print correlations
print(causation_first_rdm_correlation)
print(freesort_first_rdm_correlation)

# Compute correlation difference
correlation_difference_orders <- causation_first_rdm_correlation - freesort_first_rdm_correlation
correlation_difference_orders

```





# Correlations: Freesort

Correlations between Empirical freesort RDMs and theories

## compute correlations

d_correlations structure:
1. subject_id (char) = subject id
2. itemA (char) = first item
3. itemB (char) = second item
4. emp_euclidean (num) = empirical euclidean ratings as a disimilarity;
                        (formula: euclidean_distance = sqrt((x_itemA - x_itemB)^2 + (y_itemA - y_itemB)^2), #get euclidean distance
                                  emp_euclidean = ((euclidean_distance - min(euclidean_distance)) / #normalize it
                                                  (max(euclidean_distance) - min(euclidean_distance))))
5. emp_causal_judgments (num) = empirical causal ratings as a disimilarity (converted);
                                (formula: 1 - response / 100)
6. theor1_Mind-Body-Action (num) = theoretical rdm 1
7. theor2_PerCog-OdActSpAct-BodyStimBodynoStim (num) = theoretical rdm  2
8. theor3_Physical-Ethereal (num) = theoretical rdm 3
9. theor4_cosine_similarity (num) = theoretical rdm 4
10. 1_Mind-Body-Action (num) = correlation between theoretical rdm 1 and emp_euclidean
11. 2_PerCog-ObjDir-Stimulus (num) = correlation between theoretical rdm 2 and empirical_euclidean
12. 3_Physical-Ethereal (num) = correlation between theoretical rdm 3 and empirical_euclidean
13. 4_cosine_similarity (num) = correlation between theoretical rdm 4 and empirical_euclidean
14. 5_causal_judgments (num) = correlation between theoretical rdm 1 and emp_causal_judgments

```{r, message = FALSE}
d_all_theories <- read_csv(theories_all_input_path)

#fn to extract upper triangular part as a vector
extract_upper_tri <- function(matrix) {
  matrix[upper.tri(matrix)]
}

compute_rdm_correlation <- function(data, emp_col, theor_col, desired_order, method = "kendall") {
  rdm1 <- data %>%
    select(itemA, itemB, {{ emp_col }}) %>%
    pivot_wider(names_from = itemB, values_from = {{ emp_col }}) %>%
    column_to_rownames("itemA") %>%
    as.matrix()
  
  rdm2 <- data %>%
    select(itemA, itemB, {{ theor_col }}) %>%
    pivot_wider(names_from = itemB, values_from = {{ theor_col }}) %>%
    column_to_rownames("itemA") %>%
    as.matrix()
  
  rdm1 <- rdm1[desired_order, desired_order]
  rdm2 <- rdm2[desired_order, desired_order]
  
  cor(rdm1[upper.tri(rdm1)], rdm2[upper.tri(rdm2)], method = method)
}

d_correlations <- df_combined %>%
  left_join(d_all_theories, by = c("itemA", "itemB")) %>%
  group_by(subject_id) %>%
  mutate(
    `1_Mind-Body-Action` = compute_rdm_correlation(pick(everything()), emp_euclidean, `theor1_Mind-Body-Action`, desired_order),
    `2_PerCog-ObjDir-Stimulus` = compute_rdm_correlation(pick(everything()), emp_euclidean, `theor2_PerCog-OdActSpAct-BodyStimBodynoStim`, desired_order),
    `3_Physical-Ethereal` = compute_rdm_correlation(pick(everything()), emp_euclidean, `theor3_Physical-Ethereal`, desired_order),
    `4_cosine_similarity` = compute_rdm_correlation(pick(everything()), emp_euclidean, `theor4_cosine_similarity`, desired_order),
    `5_causal_judgments` = compute_rdm_correlation(pick(everything()), emp_euclidean, `emp_causal_judgments`, desired_order)
  ) %>%
  ungroup() %>%
  relocate(emp_causal_judgments, .after = "emp_euclidean")


calculate_noise_ceiling <- function(data, subjects, desired_order, metric = "kendall") {
  # Initialize storage for correlations
  upper_bound <- numeric(length(subjects))
  lower_bound <- numeric(length(subjects))
  
  # Loop through each subject
  for (i in seq_along(subjects)) {
    subject <- subjects[i]
    
    # Subject's RDM
    subject_rdm <- data %>%
        filter(subject_id == subject) %>%
        select(subject_id, itemA, itemB, emp_euclidean) %>% 
        pivot_wider(names_from = itemB, values_from = emp_euclidean) %>%
        column_to_rownames("itemA") %>%
        as.matrix()
    subject_rdm <- subject_rdm[desired_order, desired_order]
    
    # Grand average RDM
    grand_avg_rdm <- data %>%
        select(subject_id, itemA, itemB, emp_euclidean) %>% 
        unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>% 
        group_by(item_pairs) %>%
        mutate(emp_euclidean = mean(emp_euclidean)) %>%
        ungroup() %>% 
        distinct(item_pairs, .keep_all = TRUE) %>% 
        select(-c(item_pairs, subject_id)) %>% 
        pivot_wider(names_from = itemB, values_from = emp_euclidean) %>%
        column_to_rownames("itemA") %>%
        as.matrix()
    grand_avg_rdm <- grand_avg_rdm[desired_order, desired_order]
    
    # Other subjects' average RDM
    other_avg_rdm <- data %>%
      select(subject_id, itemA, itemB, emp_euclidean) %>% 
      filter(subject_id != "subj_01") %>%
      unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>% 
      group_by(item_pairs) %>%
      mutate(emp_euclidean = mean(emp_euclidean)) %>%
      ungroup() %>% 
      distinct(item_pairs, .keep_all = TRUE) %>% 
      select(-c(item_pairs, subject_id)) %>% 
      pivot_wider(names_from = itemB, values_from = emp_euclidean) %>%
      column_to_rownames("itemA") %>%
      as.matrix()
    other_avg_rdm <- other_avg_rdm[desired_order, desired_order]
    
    # Convert to numeric vectors
    subject_upper <- as.numeric(subject_rdm[upper.tri(subject_rdm)])
    other_upper <- as.numeric(other_avg_rdm[upper.tri(other_avg_rdm)])
    grand_upper <- as.numeric(grand_avg_rdm[upper.tri(grand_avg_rdm)])
    
    # Compute correlations
    upper_bound[i] <- cor(subject_upper, other_upper, method = metric)
    lower_bound[i] <- cor(subject_upper, grand_upper, method = metric)
  }
  
  # Return average bounds
  list(
    upper_bound = mean(upper_bound, na.rm = TRUE),
    lower_bound = mean(lower_bound, na.rm = TRUE)
  )
}

# Compute noise ceiling for all subjects
subjects <- unique(d_correlations$subject_id)
noise_ceiling <- calculate_noise_ceiling(d_correlations, subjects, desired_order)
noise_ceiling

#saving d_correlations
write.csv(d_correlations, file = correlations_output_path, row.names = F)

```

## plot correlations with noise ceiling

```{r, fig.width = 12}
# plot with noise ceiling
d_correlations_renamed <- d_correlations %>% 
  rename("3 Category" = `1_Mind-Body-Action`,
         "6 Category" = `2_PerCog-ObjDir-Stimulus`,
         "2 Category" = `3_Physical-Ethereal`,
         "Cosine Similarity" = `4_cosine_similarity`) 

d_correlations_renamed %>%
  pivot_longer(
               #cols = starts_with(c("1_","2_","3_","4_", "5_")),
               cols = c("2 Category", "3 Category", "6 Category", "Cosine Similarity"),
               names_to = "correlation_type",
               values_to = "correlation_value") %>%
  ggplot(aes(x = reorder(correlation_type, correlation_value, FUN = function(x) -mean(x)), y = correlation_value)) +
  stat_summary(fun = "mean", geom = "bar", fill = "white", color = "black") +
  geom_point(aes(color = subject_id)) +
  geom_hline(yintercept = noise_ceiling$upper_bound, color = "blue", linetype = "dashed", linewidth = .5) +
  geom_hline(yintercept = noise_ceiling$lower_bound, color = "red", linetype = "dashed", linewidth = .5) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        legend.position = "none") +
  labs(x = "Theoretical RDMs", y = "Correlation with euclidean RDMs",
       title = "Correlation between theoretical and empirical RDMs",
       subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling$upper_bound, 3),
                         " | Lower: ", round(noise_ceiling$lower_bound, 3)))

```

## figure for paper

```{r}
# Aggregate the data to calculate the mean correlation value per subject
aggregated_data <- d_correlations_renamed %>%
  pivot_longer(
    cols = c("2 Category", "3 Category", "6 Category", "Cosine Similarity"),
    names_to = "correlation_type",
    values_to = "correlation_value"
  ) %>%
  group_by(subject_id, correlation_type) %>%
  summarize(mean_correlation = mean(correlation_value, na.rm = TRUE), .groups = "drop")

# Plot the aggregated data
ggplot(aggregated_data, aes(x = reorder(correlation_type, mean_correlation, FUN = function(x) -mean(x)), 
                            y = mean_correlation)) +
  stat_summary(
    fun = "mean",
    geom = "bar",
    fill = "#95d2d6",
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_se,
    geom = "errorbar",
    width = 0.3,
    color = "black"
  ) +
  geom_point(alpha = 0.1, size = 2) +  # One point per subject
  geom_hline(yintercept = noise_ceiling$upper_bound, color = "blue", linetype = "dashed", linewidth = 0.5) +
  geom_hline(yintercept = noise_ceiling$lower_bound, color = "red", linetype = "dashed", linewidth = 0.5) +
  theme(
    axis.text.x = element_text(angle = 20, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    legend.position = "none"
  ) +
  labs(
    x = "Theoretical RDMs",
    y = "Correlation with Euclidean RDMs",
    title = "Correlation between Theoretical and Empirical RDMs",
    subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling$upper_bound, 3),
                      " | Lower: ", round(noise_ceiling$lower_bound, 3))
  )

```


```{r}
# Plot the aggregated data
ggplot(aggregated_data, aes(x = reorder(correlation_type, mean_correlation, FUN = function(x) -mean(x)), 
                            y = mean_correlation)) +
  stat_summary(
    fun = "mean",
    geom = "bar",
    fill = "#95d2d6",
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_se,
    geom = "errorbar",
    width = 0.3,
    color = "black"
  ) +
  geom_point(alpha = 0.1, size = 2) +  # One point per subject
  geom_hline(yintercept = noise_ceiling$upper_bound, color = "blue", linetype = "dashed", linewidth = 0.5) +
  geom_hline(yintercept = noise_ceiling$lower_bound, color = "red", linetype = "dashed", linewidth = 0.5) +
  stat_summary(
    fun = "mean",
    geom = "text",
    aes(label = round(..y.., 2)),  # Round and display the mean value
    vjust = -0.5,  # Adjust vertical position of text above the bar
    color = "black"
  ) +
  theme(
    axis.text.x = element_text(angle = 20, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    legend.position = "none"
  ) +
  labs(
    x = "Theoretical RDMs",
    y = "Correlation with Euclidean RDMs",
    title = "Correlation between Theoretical and Empirical RDMs",
    subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling$upper_bound, 3),
                      " | Lower: ", round(noise_ceiling$lower_bound, 3))
  )
```



## plot correlations with different order

```{r}

df_causation_first <- df_combined %>% 
  filter(trial_type_order == "causation_first")

df_freesort_first <- df_combined %>% 
  filter(trial_type_order == "causation_second")

# Apply the function in your pipeline
d_correlations_causation_first <- df_combined %>%
  left_join(d_all_theories, by = c("itemA", "itemB")) %>%
  filter(trial_type_order == "causation_first") %>% 
  group_by(subject_id) %>%
  mutate(
    `1_Mind-Body-Action` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor1_Mind-Body-Action`, desired_order),
    `2_PerCog-ObjDir-Stimulus` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor2_PerCog-OdActSpAct-BodyStimBodynoStim`, desired_order),
    `3_Physical-Ethereal` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor3_Physical-Ethereal`, desired_order),
    `4_cosine_similarity` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor4_cosine_similarity`, desired_order),
    `5_causal_judgments` = compute_rdm_correlation(cur_data(), emp_euclidean, `emp_causal_judgments`, desired_order)
  ) %>%
  ungroup() %>%
  relocate(emp_causal_judgments, .after = "emp_euclidean")

# Compute noise ceiling for all subjects
subjects_causation_first <- unique(d_correlations_causation_first$subject_id)
noise_ceiling_causation_first <- calculate_noise_ceiling(d_correlations_causation_first, subjects_causation_first, desired_order)

#===============================================================================

# Apply the function in your pipeline
d_correlations_freesort_first <- df_combined %>%
  left_join(d_all_theories, by = c("itemA", "itemB")) %>%
  filter(trial_type_order == "causation_second") %>% 
  group_by(subject_id) %>%
  mutate(
    `1_Mind-Body-Action` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor1_Mind-Body-Action`, desired_order),
    `2_PerCog-ObjDir-Stimulus` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor2_PerCog-OdActSpAct-BodyStimBodynoStim`, desired_order),
    `3_Physical-Ethereal` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor3_Physical-Ethereal`, desired_order),
    `4_cosine_similarity` = compute_rdm_correlation(cur_data(), emp_euclidean, `theor4_cosine_similarity`, desired_order),
    `5_causal_judgments` = compute_rdm_correlation(cur_data(), emp_euclidean, `emp_causal_judgments`, desired_order)
  ) %>%
  ungroup() %>%
  relocate(emp_causal_judgments, .after = "emp_euclidean")

# Compute noise ceiling for all subjects
subjects_freesort_first <- unique(d_correlations_freesort_first$subject_id)
noise_ceiling_freesort_first <- calculate_noise_ceiling(d_correlations_freesort_first, subjects_freesort_first, desired_order)

```

## order effects plots rdms

```{r}
# plot with noise ceiling
d_correlations_causation_first %>%
  pivot_longer(cols = starts_with(c("1_","2_","3_","4_", "5_")),
               names_to = "correlation_type",
               values_to = "correlation_value") %>%
  ggplot(aes(x = reorder(correlation_type, correlation_value, FUN = function(x) -mean(x)), y = correlation_value)) +
  stat_summary(fun = "mean", geom = "bar", fill = "white", color = "black") +
  geom_point(aes(color = subject_id)) +
  geom_hline(yintercept = noise_ceiling_causation_first$upper_bound, color = "blue", linetype = "dashed", linewidth = .5) +
  geom_hline(yintercept = noise_ceiling_causation_first$lower_bound, color = "red", linetype = "dashed", linewidth = .5) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14)) +
  labs(x = "Theoretical RDMs", y = "Correlation",
       title = "Correlation between theoretical and empirical RDMs - causation first",
       subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling_causation_first$upper_bound, 3),
                         " | Lower: ", round(noise_ceiling_causation_first$lower_bound, 3)))


# plot with noise ceiling
d_correlations_freesort_first %>%
  pivot_longer(cols = starts_with(c("1_","2_","3_","4_", "5_")),
               names_to = "correlation_type",
               values_to = "correlation_value") %>%
  ggplot(aes(x = reorder(correlation_type, correlation_value, FUN = function(x) -mean(x)), y = correlation_value)) +
  stat_summary(fun = "mean", geom = "bar", fill = "white", color = "black") +
  geom_point(aes(color = subject_id)) +
  geom_hline(yintercept = noise_ceiling_freesort_first$upper_bound, color = "blue", linetype = "dashed", linewidth = .5) +
  geom_hline(yintercept = noise_ceiling_freesort_first$lower_bound, color = "red", linetype = "dashed", linewidth = .5) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14)) +
  labs(x = "Theoretical RDMs", y = "Correlation",
       title = "Correlation between theoretical and freesort RDMs - causation second",
       subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling_freesort_first$upper_bound, 3),
                         " | Lower: ", round(noise_ceiling_freesort_first$lower_bound, 3)))

```

## order effects more overally

adding here because uses d_correlations

```{r}
# #checking distribution (looks equal, good)
# d %>% 
#   distinct(subject_id, trial_type, .keep_all = T) %>% 
#   count(trial_type, trial_type_order)
# 
#get order data
# d_order <- d_correlations %>%
#   unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>%
#   left_join(d %>%
#               select(subject_id, itemA, itemB, trial_type, trial_type_order) %>%
#               unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>%
#               select(-c(itemA, itemB)),
#             by = c("subject_id", "item_pairs")) %>%
#   select(subject_id, itemA, itemB, emp_euclidean, emp_causal_judgments, trial_type, trial_type_order) %>%
#   mutate(domain_itemA = case_when(itemA == "hear something" ~ "mind", #labels for first item of pair
#                              itemA == "choose what to do" ~ "mind",
#                              itemA == "remember something" ~ "mind",
#                              itemA == "think about something" ~ "mind",
#                              itemA == "see something" ~ "mind",
#                              itemA == "reach for something" ~ "action",
#                              itemA == "sit down" ~ "action",
#                              itemA == "jump up and down" ~ "action",
#                              itemA == "kick something" ~ "action",
#                              itemA == "take a walk" ~ "action",
#                              itemA == "get tired" ~ "bio",
#                              itemA == "become hungry" ~ "bio",
#                              itemA == "feel scared"~ "bio",
#                              itemA == "experience pain"~ "bio",
#                              itemA == "get sick"~ "bio"),
#          domain_itemB = case_when(itemB == "hear something" ~ "mind",
#                                itemB == "choose what to do" ~ "mind",
#                                itemB == "remember something" ~ "mind",
#                                itemB == "think about something" ~ "mind",
#                                itemB == "see something" ~ "mind",
#                                itemB == "reach for something" ~ "action",
#                                itemB == "sit down" ~ "action",
#                                itemB == "jump up and down" ~ "action",
#                                itemB == "kick something" ~ "action",
#                                itemB == "take a walk" ~ "action",
#                                itemB == "get tired" ~ "bio",
#                                itemB == "become hungry" ~ "bio",
#                                itemB == "feel scared"~ "bio",
#                                itemB == "experience pain"~ "bio",
#                                itemB == "get sick"~ "bio"))
# 
# # Summary statistics
# d_order_summary <- d_order %>%
#   group_by(trial_type, trial_type_order) %>%
#   summarize(
#     mean_emp_euclidean = mean(emp_euclidean, na.rm = TRUE),
#     sd_emp_euclidean = sd(emp_euclidean, na.rm = TRUE),
#     mean_emp_causal = mean(emp_causal_judgments, na.rm = TRUE),
#     sd_emp_causal = sd(emp_causal_judgments, na.rm = TRUE),
#     .groups = "drop"
#   )
# 
# print(d_order_summary)

```
 ## second order correlation

```{r}
# d_correlations_causation_first
# 
# dput(head(d_correlations_causation_first))
# dput(head(d_correlations_freesort_first))
# 
# 
# fisher_z_test <- function(r1, r2, n1, n2) {
#   z1 <- atanh(r1)  # Fisher transformation
#   z2 <- atanh(r2)
#   z_diff <- (z1 - z2) / sqrt(1 / (n1 - 3) + 1 / (n2 - 3))
#   p_value <- 2 * (1 - pnorm(abs(z_diff)))  # Two-tailed p-value
#   return(p_value)
# }
# 
# # Example: Compare cor_theor1_emp between groups
# p_value <- fisher_z_test(
#   r1 = d_correlations_causation_first$`1_Mind-Body-Action`,
#   r2 = d_correlations_freesort_first$`1_Mind-Body-Action`,
#   n1 = length(subjects_causation_first),
#   n2 = length(subjects_freesort_first)
# )

# cat("P-value for difference in cor_theor1_emp:", p_value, "\n")


```

```{r}
# Split data into two task orders
# group1 <- d_correlations %>% filter(order == "causation_first")
# group2 <- d_correlations %>% filter(order == "causation_second")
```



```{r}
# plot with noise ceiling
# d_correlations %>%
#   pivot_longer(cols = starts_with(c("1_","2_","3_","4_", "5_")),
#                names_to = "correlation_type",
#                values_to = "correlation_value") %>%
#   ggplot(aes(x = reorder(correlation_type, correlation_value, FUN = function(x) -mean(x)), y = correlation_value)) +
#   stat_summary(fun = "mean", geom = "bar", fill = "white", color = "black") +
#   geom_point(aes(color = subject_id)) +
#   geom_hline(yintercept = noise_ceiling$upper_bound, color = "blue", linetype = "dashed", linewidth = .5) +
#   geom_hline(yintercept = noise_ceiling$lower_bound, color = "red", linetype = "dashed", linewidth = .5) +
#   theme(axis.text.x = element_text(angle = 20, hjust = 1, size = 12),
#         axis.text.y = element_text(size = 12),
#         axis.title.x = element_text(size = 14),
#         axis.title.y = element_text(size = 14)) +
#   labs(x = "Theoretical RDMs", y = "Correlation with euclidean RDMs",
#        title = "Correlation between theoretical and empirical RDMs",
#        subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling$upper_bound, 3),
#                          " | Lower: ", round(noise_ceiling$lower_bound, 3)))
```



# Viz score distribution

## Prep plots

### grabbing closest items in causal and similarity space

```{r}
#scrap notes
# ok so question, do we want to get the mean, and then get the minimum, or get the minimum and then get the mean? Ugh maybe both?
# once we get the mean there is no range so no min or max, no? Actually there is. Each item is paired with each other item. So there's a range of means. You can get the max or min mean

d_correlations <- read_csv(correlations_output_path)

#actually i should group by itemB and get mean for those!! REDOING. Delete above code when done here..tried, someting was off

##fff i need to first get the pair means and then get the itemB means (a mean of means!)

d_correlations_short <- d_correlations %>% #get pair means
  select(subject_id, itemA, itemB, emp_euclidean, emp_causal_judgments) %>% 
  unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>% 
  group_by(item_pairs) %>%
  summarize(mean_causal_dissimilarity = mean(emp_causal_judgments, na.rm = TRUE),
         mean_emp_euclidean = mean(emp_euclidean, na.rm = TRUE)) %>% #make sure these did not flip!!
  ungroup() %>% 
  separate(item_pairs, c("itemA", "itemB"), sep = "_")

d_corr_means <- d_correlations_short %>% # get itemB means
  # filter(itemB == "choose what to do")
  group_by(itemB) %>%
  mutate(mean_itemB_causal_dissimilarity = mean(mean_causal_dissimilarity, na.rm = TRUE),
         mean_itemB_emp_euclidean = mean(mean_emp_euclidean, na.rm = TRUE)) %>% #ok, gets all the means
  ungroup() 

d_corr_means_causal_mins <- d_corr_means %>% 
  group_by(itemB) %>% 
  slice_min(mean_causal_dissimilarity) %>% #get min causal score. should we slice off the corresponding euclidean score? No but maybe lets rename columns accordingly
  ungroup()

d_corr_means_emp_mins <- d_corr_means %>% 
  group_by(itemB) %>% 
  slice_min(mean_emp_euclidean) %>% 
  ungroup()

#this is it!
d_intervention_items <- d_corr_means_causal_mins %>% 
  rename("causal_itemA" = itemA,
         "min_causal_dissimilarity_causalAitemB" = mean_causal_dissimilarity,
         "corr_emp_euclidean_causalAitemB" = mean_emp_euclidean) %>%
  left_join(d_corr_means_emp_mins %>% 
              select(itemA, itemB, mean_causal_dissimilarity, mean_emp_euclidean) %>% 
              rename("similarity_itemA" = itemA,
                     "corr_causal_dissimilarity_simAitemB" = mean_causal_dissimilarity,
                     "min_emp_euclidean_simAitemB" = mean_emp_euclidean),
            by = "itemB") %>% 
  relocate("similarity_itemA", .before = "itemB") %>% 
  rename("mean_mean_itemB_causal_dissimilarity" = mean_itemB_causal_dissimilarity,
         "mean_mean_itemB_causal_dissimilarity" = mean_itemB_causal_dissimilarity)

#scrap: d_intervention columns meaning
#mean_itemB_.. : mean of mean itemB scores with all other items
#mean_causal_ and mean_emp_ : contains the mean pair scores between itemB and itemA, in this case only shows the lowest itemAs #matched with itemB causals, and the corresponding euclideans..

# the least confusing version of this dataframe: sjust show most causal and most similar
d_intervention_items_simple <- d_intervention_items %>% 
  select(causal_itemA, similarity_itemA, itemB, min_causal_dissimilarity_causalAitemB, min_emp_euclidean_simAitemB) 
 
write.csv(d_intervention_items, file = paste0(snapshots_output_path, "/intervention_items.csv"), row.names = F)

##==========second to last items
d_corr_means_causal_penultimate_mins <- d_corr_means %>% 
  group_by(itemB) %>% 
  slice(n() - 1) %>% #select the second-to-last item
  ungroup()

d_corr_means_emp_penultimate_mins <- d_corr_means %>% 
  group_by(itemB) %>% 
  arrange(mean_emp_euclidean) %>%  #arange by the column to ensure proper ordering
  slice(n() - 1) %>%              #select the second-to-last item
  ungroup()

d_intervention_penultimate_items <- d_corr_means_causal_penultimate_mins %>% 
  rename("causal_itemA" = itemA,
         "min_causal_dissimilarity_causalAitemB" = mean_causal_dissimilarity,
         "corr_emp_euclidean_causalAitemB" = mean_emp_euclidean) %>%
  left_join(d_corr_means_emp_penultimate_mins %>% 
              select(itemA, itemB, mean_causal_dissimilarity, mean_emp_euclidean) %>% 
              rename("similarity_itemA" = itemA,
                     "corr_causal_dissimilarity_simAitemB" = mean_causal_dissimilarity,
                     "min_emp_euclidean_simAitemB" = mean_emp_euclidean),
            by = "itemB") %>% 
  relocate("similarity_itemA", .before = "itemB") %>% 
  rename("mean_mean_itemB_causal_dissimilarity" = mean_itemB_causal_dissimilarity,
         "mean_mean_itemB_causal_dissimilarity" = mean_itemB_causal_dissimilarity)
 
write.csv(d_intervention_penultimate_items, file = paste0(snapshots_output_path, "/intervention_penultimate_items.csv"), row.names = F)

```

### grabbing most distant items in causal & similarity space (i.e max value items) 

```{r}
d_corr_means_causal_maxs <- d_corr_means %>% 
  group_by(itemB) %>% 
  slice_max(mean_causal_dissimilarity) %>% #get min causal score. should we slice off the corresponding euclidean score? No but maybe lets rename columns accordingly
  ungroup()

d_corr_means_emp_maxs <- d_corr_means %>% 
  group_by(itemB) %>% 
  slice_max(mean_emp_euclidean) %>% 
  ungroup()

#this is it!
d_intervention_items_max <- d_corr_means_causal_maxs %>% 
  rename("causal_itemA" = itemA,
         "max_causal_dissimilarity_causalAitemB" = mean_causal_dissimilarity,
         "corr_emp_euclidean_causalAitemB" = mean_emp_euclidean) %>%
  left_join(d_corr_means_emp_maxs %>% 
              select(itemA, itemB, mean_causal_dissimilarity, mean_emp_euclidean) %>% 
              rename("similarity_itemA" = itemA,
                     "corr_causal_dissimilarity_simAitemB" = mean_causal_dissimilarity,
                     "max_emp_euclidean_simAitemB" = mean_emp_euclidean),
            by = "itemB") %>% 
  relocate("similarity_itemA", .before = "itemB") %>% 
  rename("mean_mean_itemB_causal_dissimilarity" = mean_itemB_causal_dissimilarity,
         "mean_mean_itemB_causal_dissimilarity" = mean_itemB_causal_dissimilarity)


causal_max <- d_intervention_items_max %>% 
  select(causal_itemA, itemB, max_causal_dissimilarity_causalAitemB) %>% 
  rename("mean_causal_dissimilarity" = max_causal_dissimilarity_causalAitemB,#the minimum values, that is
         "itemA" = causal_itemA) %>% 
  pivot_longer(cols = mean_causal_dissimilarity, names_to = "mean_type", values_to = "values")

euclidean_max <- d_intervention_items_max %>% 
  select(similarity_itemA, itemB, max_emp_euclidean_simAitemB) %>% 
  rename("mean_emp_euclidean" = max_emp_euclidean_simAitemB, #the minimum values, that is
         "itemA" = similarity_itemA) %>% 
  pivot_longer(cols = mean_emp_euclidean, names_to = "mean_type", values_to = "values")

d_corr_means_labels_max <- bind_rows(euclidean_max, causal_max)

```

### grabbing item A labels for the plot

```{r}
d_intervention_items %>% 
  select(causal_itemA, similarity_itemA, itemB, min_causal_dissimilarity_causalAitemB, min_emp_euclidean_simAitemB) 

causal <- d_intervention_items %>% 
  select(causal_itemA, itemB, min_causal_dissimilarity_causalAitemB) %>% 
  rename("mean_causal_dissimilarity" = min_causal_dissimilarity_causalAitemB,#the minimum values, that is
         "itemA" = causal_itemA) %>% 
  pivot_longer(cols = mean_causal_dissimilarity, names_to = "mean_type", values_to = "values")

euclidean <- d_intervention_items %>% 
  select(similarity_itemA, itemB, min_emp_euclidean_simAitemB) %>% 
  rename("mean_emp_euclidean" = min_emp_euclidean_simAitemB, #the minimum values, that is
         "itemA" = similarity_itemA) %>% 
  pivot_longer(cols = mean_emp_euclidean, names_to = "mean_type", values_to = "values")

d_corr_means_labels <- bind_rows(euclidean, causal)
  
```

### adding domain data, specifying colors for domains and y axis labels

```{r}
d_corr_means_domain <- d_corr_means %>% 
  mutate(domain_itemA = case_when(itemA == "hear something" ~ "mind", #labels for first item of pair
                             itemA == "choose what to do" ~ "mind",
                             itemA == "remember something" ~ "mind",
                             itemA == "think about something" ~ "mind",
                             itemA == "see something" ~ "mind",
                             itemA == "reach for something" ~ "action",
                             itemA == "sit down" ~ "action", 
                             itemA == "jump up and down" ~ "action",
                             itemA == "kick something" ~ "action",
                             itemA == "take a walk" ~ "action",
                             itemA == "get tired" ~ "bio", 
                             itemA == "become hungry" ~ "bio",
                             itemA == "feel scared"~ "bio",
                             itemA == "experience pain"~ "bio",
                             itemA == "get sick"~ "bio"),
         domain_itemB = case_when(itemB == "hear something" ~ "mind", 
                               itemB == "choose what to do" ~ "mind",
                               itemB == "remember something" ~ "mind",
                               itemB == "think about something" ~ "mind",
                               itemB == "see something" ~ "mind",
                               itemB == "reach for something" ~ "action",
                               itemB == "sit down" ~ "action", 
                               itemB == "jump up and down" ~ "action",
                               itemB == "kick something" ~ "action",
                               itemB == "take a walk" ~ "action",
                               itemB == "get tired" ~ "bio", 
                               itemB == "become hungry" ~ "bio",
                               itemB == "feel scared"~ "bio",
                               itemB == "experience pain"~ "bio",
                               itemB == "get sick"~ "bio")) %>% 
  relocate(domain_itemA, .after = "itemB") %>% 
  relocate(domain_itemB, .after = "domain_itemA") %>% 
  mutate(itemB = factor(itemB, levels = desired_order))


# Pivot the main dataframe for plotting
d_corr_means_domain_long <- d_corr_means_domain %>%
  pivot_longer(
    cols = c("mean_causal_dissimilarity", "mean_emp_euclidean"),
    names_to = "mean_type",
    values_to = "values"
  ) %>% 
  select(-c(mean_itemB_causal_dissimilarity, mean_itemB_emp_euclidean))

#colors
itemB_colors <- d_corr_means_domain_long %>%
  distinct(itemB, domain_itemB) %>%
  mutate(color = case_when(
    domain_itemB == "bio" ~ "green",
    domain_itemB == "mind" ~ "blue",
    domain_itemB == "action" ~ "red"
  )) %>%
  pull(color, name = itemB)

# Define custom colors for domain_itemA (points)
domain_itemA_colors <- c(
  "bio" = "green",
  "mind" = "blue",
  "action" = "red"
)
```

## Plot closest and most distant with labels 

```{r, fig.width = 12}
# Pivot the main dataframe for plotting
d_corr_means_long <- d_corr_means %>%
  pivot_longer(
    cols = c("mean_causal_dissimilarity", "mean_emp_euclidean"),
    names_to = "mean_type",
    values_to = "values"
  ) %>% 
  select(-c(mean_itemB_causal_dissimilarity, mean_itemB_emp_euclidean))


# Create the boxplot with labeled points
ggplot(d_corr_means_long, aes(x = itemB, y = values)) +
  geom_boxplot() +
  geom_point(aes(color = itemA)) +
  geom_text(
    data = d_corr_means_labels,
    aes(label = itemA, x = itemB, y = values),
    vjust = -0.5,
    color = "red",
    size = 2.5
  ) +
    geom_text(
    data = d_corr_means_labels_max,
    aes(label = itemA, x = itemB, y = values),
    vjust = 1.5, # Adjust to avoid overlap with the first set of labels
    color = "blue",
    size = 2.5
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") +
  facet_wrap(~mean_type)

```


## Plot with all items labelled

```{r, fig.width = 12, fig.height = 14}
p_all <- ggplot(d_corr_means_domain_long, aes(x = itemB, y = values)) +
  geom_boxplot() +
  geom_point(
    aes(color = domain_itemA)) +
  geom_text(
    aes(label = itemA, x = itemB, y = values, color = domain_itemA),
    vjust = -0.5,
    size = 2.5
  ) +
  scale_color_manual(values = domain_itemA_colors) + # Custom point colors
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = itemB_colors[levels(d_corr_means_domain_long$itemB)])
  ) +
  facet_wrap(~mean_type)

p_all

# Save the plot as a PDF
ggsave(
  filename = "my_plot_all.pdf", # Specify the file name
  plot = p_all,           # Your ggplot object
  device = "pdf",           # Save as a PDF
  #path = "path/to/directory", # Optional: specify a directory
  width = 12,                # Width of the PDF in inches
  height = 8,               # Height of the PDF in inches
  units = "in"              # Units for width and height
)

```


## Plot relative distances (euclidean - causal)

```{r, fig.width = 12}
d_diffs <- d_corr_means_domain_long %>% 
  pivot_wider(names_from = "mean_type",
              values_from = "values") %>% 
  mutate(euclidean_minus_causal = mean_emp_euclidean - mean_causal_dissimilarity)

p_diffs_2 <- d_diffs %>% 
  pivot_longer(cols = c("mean_causal_dissimilarity", "mean_emp_euclidean"),
               names_to = "mean_type",
               values_to = "values") %>% 
  ggplot(aes(x = itemB, y = euclidean_minus_causal)) +
  geom_boxplot() +
  geom_point(
    aes(color = domain_itemA)) +
  geom_text(
    aes(label = itemA, x = itemB, y = euclidean_minus_causal, color = domain_itemA),
    vjust = -0.5,
    size = 2.5
  ) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  scale_color_manual(values = domain_itemA_colors) + # Custom point colors
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = itemB_colors[levels(d_corr_means_domain_long$itemB)]),
    legend.position = "none"
  ) +
  facet_wrap(~mean_type)

p_diffs_2

# Save the plot as a PDF
ggsave(
  filename = "my_plot_diffs_2.pdf", # Specify the file name
  plot = p_diffs_2,           # Your ggplot object
  device = "pdf",           # Save as a PDF
  #path = "path/to/directory", # Optional: specify a directory
  width = 14,                # Width of the PDF in inches
  height = 8,               # Height of the PDF in inches
  units = "in"              # Units for width and height
)

write.csv(d_diffs, paste0(snapshots_output_path, "/diffs.csv"), row.names = F)

```

# Show expected effect sizes for study 2 (just run all above points first)

```{r}
#max regardless of domain
diffs_causal <- d_diffs %>%
  # group_by(itemB, domain_itemA) %>%
  # slice(which.max(euclidean_minus_causal)) %>% 
  # ungroup() %>% 
  group_by(itemB) %>% 
  slice(which.max(euclidean_minus_causal)) %>% 
  ungroup() %>% 
  rename("causal_itemA" = itemA,
         "domain_causal_itemA" = domain_itemA,
         "causals_euc_minus_causal" = euclidean_minus_causal) %>% 
  select(causal_itemA, itemB, domain_causal_itemA, domain_itemB, causals_euc_minus_causal)

itemB_colors <- diffs_causal %>%
  distinct(itemB, domain_itemB) %>%
  mutate(color = case_when(
    domain_itemB == "bio" ~ "green",
    domain_itemB == "mind" ~ "blue",
    domain_itemB == "action" ~ "red"
  )) %>%
  pull(color, name = itemB)

#min in same domain
diffs_sim <- d_diffs %>%
  group_by(itemB, domain_itemA) %>%
  slice(which.min(euclidean_minus_causal)) %>% 
  ungroup() %>% 
  mutate(same_domain = ifelse(domain_itemA == domain_itemB, TRUE, FALSE)) %>% 
  filter(same_domain == TRUE) %>% 
  ungroup() %>% 
  rename("similarity_itemA" = itemA,
       "domain_similarity_itemA" = domain_itemA,
       "sims_euc_minus_causal" = euclidean_minus_causal) %>% 
  select(similarity_itemA, itemB, domain_similarity_itemA, domain_itemB, sims_euc_minus_causal)

diffs_causal %>% 
  left_join(diffs_sim %>% 
              select(everything()), 
              by = c("itemB", "domain_itemB")) %>% 
  mutate(diff = causals_euc_minus_causal - sims_euc_minus_causal) %>% 
  ggplot(aes(itemB, diff)) +
  geom_point() +
  #theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = itemB_colors[levels(diffs_causal$itemB)])) 


```




# Summary stats

## figures

```{r}
# d_order_long <- d_order %>%
#   pivot_longer(
#     cols = c(emp_euclidean, emp_causal_judgments),
#     names_to = "dv",
#     values_to = "values"
#   )
# 
# d_order_long %>%
#   ggplot(aes(x = dv, y = values, color = trial_type_order, group = trial_type_order)) + 
#   stat_summary(
#     fun = "mean", 
#     geom = "point",
#     shape = 21, 
#     size = 3, 
#     position = position_dodge(width = 0.5) 
#   ) +
#   stat_summary(
#     fun.data = mean_se, 
#     geom = "errorbar",
#     position = position_dodge(width = 0.5),
#     width = 0.2 # Width of the error bars
#   ) +
  # geom_point(
  #   position = position_jitter(width = 0.2, height = 0), # Add jitter to avoid overlap
  #   alpha = 0.01, # Transparency for raw data points
  #   size = 1.5 # Adjust point size
  # ) +
#   ylim(0, max(d_order_long$values) + 0.1)  
# 
# #bar
# d_order_long %>%
#   ggplot(aes(x = dv, y = values, fill = trial_type_order)) +
#   stat_summary(
#     fun = "mean", # Compute the mean
#     geom = "bar",
#     position = position_dodge(),
#     width = 0.7
#   ) +
#   stat_summary(
#     fun.data = mean_se, # Compute mean and standard error
#     geom = "errorbar",
#     position = position_dodge(width = 0.7),
#     width = 0.2 # Width of the error bars
#   ) 
# 
# conflicts_prefer(lme4::lmer)
# model <- lmer(values ~ dv * trial_type_order + (1 | subject_id), data = d_order_long)
# summary(model)

```


# Correlations: Causal

## generate causal theories

```{r, echo = TRUE}
d_theo_causal_raw <- read_csv(theories_input_path) 


d_theo_causal <- d_theo_causal_raw %>% 
  select(itemA, itemB, MindBodyAction_itemA, MindBodyAction_itemB) %>% 
  mutate(within_domain_int = case_when(
                          #intuitive bio
                          MindBodyAction_itemA == "bio" & MindBodyAction_itemB == "act" ~ 0, 
                          MindBodyAction_itemA == "act" & MindBodyAction_itemB == "bio" ~ 0,
                          MindBodyAction_itemA == "bio" & MindBodyAction_itemB == "bio" ~ 0,
                          #intuitive psych
                          MindBodyAction_itemA == "mind" & MindBodyAction_itemB == "act" ~ 0, 
                          MindBodyAction_itemA == "act" & MindBodyAction_itemB == "mind" ~ 0,
                          MindBodyAction_itemA == "mind" & MindBodyAction_itemB == "mind" ~ 0,
                          TRUE ~ 1),
         cross_domain_int = case_when(
                          MindBodyAction_itemA == "bio" & MindBodyAction_itemB == "act" ~ 0, 
                          MindBodyAction_itemA == "act" & MindBodyAction_itemB == "bio" ~ 0,
                          MindBodyAction_itemA == "bio" & MindBodyAction_itemB == "bio" ~ 0,
                          
                          MindBodyAction_itemA == "mind" & MindBodyAction_itemB == "act" ~ 0, 
                          MindBodyAction_itemA == "act" & MindBodyAction_itemB == "mind" ~ 0,
                          MindBodyAction_itemA == "mind" & MindBodyAction_itemB == "mind" ~ 0,
                          #cross-domain causation
                          MindBodyAction_itemA == "mind" & MindBodyAction_itemB == "bio" ~ 0, 
                          MindBodyAction_itemA == "bio" & MindBodyAction_itemB == "mind" ~ 0,
                          TRUE ~ 1)) %>% 
  select(-c("MindBodyAction_itemA", "MindBodyAction_itemB"))

  
```

## compute correlations

```{r}
d_causal_correlations <- df_distances %>%
  left_join(d_theo_causal, by = c("itemA", "itemB")) %>%
  left_join(df_causation, by = c("subject_id", "itemA", "itemB")) %>% 
  # rename(causal_judgments` = "causal_judgments") %>% 
  group_by(subject_id) %>%
  mutate(
      `1_emp_euclideans_upper` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, emp_euclidean),   # Construct theoretical RDM
                          names_from = itemB, values_from = emp_euclidean) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        cor(rdm1[upper.tri(rdm1)], rdm2[upper.tri(rdm2)], method = "kendall")
        },

      `1_emp_euclideans_lower` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, emp_euclidean),   # Construct theoretical RDM
                          names_from = itemB, values_from = emp_euclidean) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        cor(rdm1[lower.tri(rdm1)], rdm2[lower.tri(rdm2)], method = "kendall")

        },

      `1_emp_euclideans_both` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, emp_euclidean),   # Construct theoretical RDM
                          names_from = itemB, values_from = emp_euclidean) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        # Flatten matrices and exclude NA values
        vec1 <- as.vector(rdm1)
        vec2 <- as.vector(rdm2)
        valid_indices <- !is.na(vec1) & !is.na(vec2)  # Exclude NA values
        
        cor(vec1[valid_indices], vec2[valid_indices], method = "kendall")
        },
      
      `2_within_domain_upper` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, within_domain_int),   # Construct theoretical RDM
                          names_from = itemB, values_from = within_domain_int) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        cor(rdm1[upper.tri(rdm1)], rdm2[upper.tri(rdm2)], method = "kendall")

        },
      
      `2_within_domain_lower` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, within_domain_int),   # Construct theoretical RDM
                          names_from = itemB, values_from = within_domain_int) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        cor(rdm1[lower.tri(rdm1)], rdm2[lower.tri(rdm2)], method = "kendall")

        },
      
      `2_within_domain_both` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, within_domain_int),   # Construct theoretical RDM
                          names_from = itemB, values_from = within_domain_int) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        # Flatten matrices and exclude NA values
        vec1 <- as.vector(rdm1)
        vec2 <- as.vector(rdm2)
        valid_indices <- !is.na(vec1) & !is.na(vec2)  # Exclude NA values
        
        cor(vec1[valid_indices], vec2[valid_indices], method = "kendall")

        },
      
      `3_cross_domain_upper` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, cross_domain_int),   # Construct theoretical RDM
                          names_from = itemB, values_from = cross_domain_int) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        cor(rdm1[upper.tri(rdm1)], rdm2[upper.tri(rdm2)], method = "kendall")

        },
      
      `3_cross_domain_lower` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, cross_domain_int),   # Construct theoretical RDM
                          names_from = itemB, values_from = cross_domain_int) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
        cor(rdm1[lower.tri(rdm1)], rdm2[lower.tri(rdm2)], method = "kendall")

        },
      
      `3_cross_domain_both` = {
        rdm1 <- pivot_wider(pick(itemA, itemB, emp_causal_judgments),     #empirical RDM
                          names_from = itemB, values_from = emp_causal_judgments) %>%
                column_to_rownames("itemA") %>% as.matrix()
        
        rdm2 <- pivot_wider(pick(itemA, itemB, cross_domain_int),   # Construct theoretical RDM
                          names_from = itemB, values_from = cross_domain_int) %>%
               column_to_rownames("itemA") %>% as.matrix()
        
        rdm1 <- rdm1[desired_order, desired_order] 
        rdm2 <- rdm2[desired_order, desired_order]
        
                # Flatten matrices and exclude NA values
        vec1 <- as.vector(rdm1)
        vec2 <- as.vector(rdm2)
        valid_indices <- !is.na(vec1) & !is.na(vec2)  # Exclude NA values
        
        cor(vec1[valid_indices], vec2[valid_indices], method = "kendall")

        }) %>% 
  ungroup()


```

## plot correlations with empirical causal rdms

key

1. _upper: the upper tri of the causal rdm (since causal isn't symmetric, doing correlations for each causal tri separately. always using upper tri for empirical euclidean rdms since those are symmetric) 
2. _lower: lower tri  
3. _both: remove NAs, flatten into a vector, then compute correlations between the entire theoretical rdm and the causal rdms (NB: both is not avg of upper and lower)  
4. within_domain_: a classical causal rdm involving intuitive theories within domains. mind causes act (and vice versa), bio causes act (and vice versa), mind causes mind, and bio causes bio.  
5. cross_domain_: classical causal rdm per point 4 PLUS causal relation between bio and mind (bio cause mind and vice versa) 

```{r, fig.width = 12}
# plot with noise ceiling
d_causal_correlations_renamed <- d_causal_correlations %>% 
  rename("3 Category" = `1_Mind-Body-Action`,
         "6 Category" = `2_PerCog-ObjDir-Stimulus`,
         "2 Category" = `3_Physical-Ethereal`,
         "Cosine Similarity" = `4_cosine_similarity`) 

d_causal_correlations_renamed %>%
  pivot_longer(
               #cols = starts_with(c("1_","2_","3_","4_", "5_")),
               cols = c("2 Category", "3 Category", "6 Category", "Cosine Similarity"),
               names_to = "correlation_type",
               values_to = "correlation_value") %>% 
  # mutate(category = case_when(str_starts(correlation_type, "1_") ~ "empirical euclidean",
  #                             str_starts(correlation_type, "2_") ~ "with_dom int theory",
  #                             str_starts(correlation_type, "3_") ~ "cross_dom int theory")) %>% 
  ggplot(aes(x = reorder(correlation_type, correlation_value, FUN = function(x) -mean(x)), y = correlation_value, fill = category)) +
  stat_summary(fun = "mean", geom = "bar", color = "black") +
  # stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.5) +
  geom_point(aes(color = subject_id)) +
  geom_hline(yintercept = noise_ceiling$upper_bound, color = "blue", linetype = "dashed", linewidth = .5) +
  geom_hline(yintercept = noise_ceiling$lower_bound, color = "red", linetype = "dashed", linewidth = .5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        legend.position = "none") +
  labs(x = "Theoretical RDMs", y = "Correlation with causal RDMs",
       title = "Correlation between theoretical and empirical RDMs",
       subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling$upper_bound, 3),
                         " | Lower: ", round(noise_ceiling$lower_bound, 3)))


```

## figure for paper, recompute correlations

```{r}
#fn to extract upper triangular part as a vector
extract_upper_tri <- function(matrix) {
  matrix[upper.tri(matrix)]
}

compute_rdm_correlation <- function(data, emp_col, theor_col, desired_order, method = "kendall") {
  rdm1 <- data %>%
    select(itemA, itemB, {{ emp_col }}) %>%
    pivot_wider(names_from = itemB, values_from = {{ emp_col }}) %>%
    column_to_rownames("itemA") %>%
    as.matrix()
  
  rdm2 <- data %>%
    select(itemA, itemB, {{ theor_col }}) %>%
    pivot_wider(names_from = itemB, values_from = {{ theor_col }}) %>%
    column_to_rownames("itemA") %>%
    as.matrix()
  
  rdm1 <- rdm1[desired_order, desired_order]
  rdm2 <- rdm2[desired_order, desired_order]
  
  cor(rdm1[upper.tri(rdm1)], rdm2[upper.tri(rdm2)], method = method)
}
#=======================================



d_causal_correlations <-  df_combined %>%
  left_join(d_all_theories, by = c("itemA", "itemB")) %>% 
  # rename(causal_judgments` = "causal_judgments") %>% 
  group_by(subject_id) %>%
  mutate(
    `1_Mind-Body-Action` = compute_rdm_correlation(pick(everything()), emp_causal_judgments, `theor1_Mind-Body-Action`, desired_order),
    `2_PerCog-ObjDir-Stimulus` = compute_rdm_correlation(pick(everything()), emp_causal_judgments, `theor2_PerCog-OdActSpAct-BodyStimBodynoStim`, desired_order),
    `3_Physical-Ethereal` = compute_rdm_correlation(pick(everything()), emp_causal_judgments, `theor3_Physical-Ethereal`, desired_order),
    `4_cosine_similarity` = compute_rdm_correlation(pick(everything()), emp_causal_judgments, `theor4_cosine_similarity`, desired_order),
    `5_causal_judgments` = compute_rdm_correlation(pick(everything()), emp_causal_judgments, `emp_causal_judgments`, desired_order)
  ) %>%
  ungroup() #%>%
  #relocate(emp_causal_judgments, .after = "emp_euclidean")


calculate_noise_ceiling <- function(data, subjects, desired_order, metric = "kendall") {
  # Initialize storage for correlations
  upper_bound <- numeric(length(subjects))
  lower_bound <- numeric(length(subjects))
  
  # Loop through each subject
  for (i in seq_along(subjects)) {
    subject <- subjects[i]
    
    # Subject's RDM
    subject_rdm <- data %>%
        filter(subject_id == subject) %>%
        select(subject_id, itemA, itemB, emp_causal_judgments) %>% 
        pivot_wider(names_from = itemB, values_from = emp_causal_judgments) %>%
        column_to_rownames("itemA") %>%
        as.matrix()
    subject_rdm <- subject_rdm[desired_order, desired_order]
    
    # Grand average RDM
    grand_avg_rdm <- data %>%
        select(subject_id, itemA, itemB, emp_causal_judgments) %>% 
        unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>% 
        group_by(item_pairs) %>%
        mutate(emp_causal_judgments = mean(emp_causal_judgments)) %>%
        ungroup() %>% 
        distinct(item_pairs, .keep_all = TRUE) %>% 
        select(-c(item_pairs, subject_id)) %>% 
        pivot_wider(names_from = itemB, values_from = emp_causal_judgments) %>%
        column_to_rownames("itemA") %>%
        as.matrix()
    grand_avg_rdm <- grand_avg_rdm[desired_order, desired_order]
    
    # Other subjects' average RDM
    other_avg_rdm <- data %>%
      select(subject_id, itemA, itemB, emp_causal_judgments) %>% 
      filter(subject_id != "subj_01") %>%
      unite("item_pairs", itemA, itemB, sep = "_", remove = FALSE) %>% 
      group_by(item_pairs) %>%
      mutate(emp_causal_judgments = mean(emp_causal_judgments)) %>%
      ungroup() %>% 
      distinct(item_pairs, .keep_all = TRUE) %>% 
      select(-c(item_pairs, subject_id)) %>% 
      pivot_wider(names_from = itemB, values_from = emp_causal_judgments) %>%
      column_to_rownames("itemA") %>%
      as.matrix()
    other_avg_rdm <- other_avg_rdm[desired_order, desired_order]
    
    # Convert to numeric vectors
    subject_upper <- as.numeric(subject_rdm[upper.tri(subject_rdm)])
    other_upper <- as.numeric(other_avg_rdm[upper.tri(other_avg_rdm)])
    grand_upper <- as.numeric(grand_avg_rdm[upper.tri(grand_avg_rdm)])
    
    # Compute correlations
    upper_bound[i] <- cor(subject_upper, other_upper, method = metric)
    lower_bound[i] <- cor(subject_upper, grand_upper, method = metric)
  }
  
  # Return average bounds
  list(
    upper_bound = mean(upper_bound, na.rm = TRUE),
    lower_bound = mean(lower_bound, na.rm = TRUE)
  )
}

# Compute noise ceiling for all subjects
subjects <- unique(d_correlations$subject_id)
noise_ceiling <- calculate_noise_ceiling(d_correlations, subjects, desired_order)
noise_ceiling

#saving d_correlations
#write.csv(d_correlations, file = correlations_output_path, row.names = F)
```

## figure for paper

```{r, fig.width = 8, fig.height = 7}
# plot with noise ceiling
d_causal_correlations_renamed <- d_causal_correlations %>% 
  rename("3 Category" = `1_Mind-Body-Action`,
         "6 Category" = `2_PerCog-ObjDir-Stimulus`,
         "2 Category" = `3_Physical-Ethereal`,
         "Cosine Similarity" = `4_cosine_similarity`) 


# Aggregate the data to calculate the mean correlation value per subject
aggregated_causal_data <- d_causal_correlations_renamed %>%
  pivot_longer(
    cols = c("2 Category", "3 Category", "6 Category", "Cosine Similarity"),
    names_to = "correlation_type",
    values_to = "correlation_value"
  ) %>%
  group_by(subject_id, correlation_type) %>%
  summarize(mean_correlation = mean(correlation_value, na.rm = TRUE), .groups = "drop")


# Plot the aggregated data
ggplot(aggregated_causal_data, aes(x = reorder(correlation_type, mean_correlation, FUN = function(x) -mean(x)), 
                            y = mean_correlation)) +
  stat_summary(
    fun = "mean",
    geom = "bar",
    fill = "#95d2d6",
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_se,
    geom = "errorbar",
    width = 0.3,
    color = "black"
  ) +
  geom_point(alpha = 0.1, size = 2) +  # One point per subject
  geom_hline(yintercept = noise_ceiling$upper_bound, color = "blue", linetype = "dashed", linewidth = 0.5) +
  geom_hline(yintercept = noise_ceiling$lower_bound, color = "red", linetype = "dashed", linewidth = 0.5) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    legend.position = "none"
  ) +
  theme(
      plot.title = element_text(hjust = 0.5),  # Center the title
      # axis.text.x = element_text(size = 12),  # Adjust size of x-axis labels
      axis.ticks.x = element_blank(),        # Remove default x-axis title
      plot.margin = margin(20, 20, 20, 20)   # Adjust margins for better spacing
  ) +
  labs(
    x = NULL,
    y = "Euclidean RDM Correlation",
    title = "Correlation between Theoretical and Empirical Causal RDMs",
    subtitle = paste0("Noise Ceiling: Upper: ", round(noise_ceiling$upper_bound, 3),
                      " | Lower: ", round(noise_ceiling$lower_bound, 3))
  )


```








still to do: causal rdms where everything can cause everything except for certain conditions..  

- There are limits to what can cause perception (seeing or hearing something) - at least directly. For instance, mental and bodily events cant literally cause you to see something. But moving ones body around can.    
- Certain physiological events limit what the body can do - e.g. feeling sick and hungry tends to not lead to high-intensity actions like jumping, kicking, walking. Energy flows downhill.  
- Certain actions constrain what next actions are possible, e.g. resting actions like sitting down tend not to cause high energy actions.  
- ??? Perceptual events (seeing or hearing) cannot directly cause physiological states like being tired, being in pain - but cognitive events can.   


```{r}

```

